#  Semana 4 - Fundamentos de Funciones en JavaScript

!!! info "IntroducciÃ³n"
    Las **funciones** son uno de los pilares fundamentales de JavaScript, un lenguaje de programaciÃ³n dinÃ¡mico y versÃ¡til. Las funciones permiten encapsular bloques de cÃ³digo reutilizables, facilitando la organizaciÃ³n, modularidad y mantenimiento del cÃ³digo. En esta semana, exploraremos los conceptos bÃ¡sicos de las funciones: quÃ© son, cÃ³mo se definen, sus diferentes tipos y cÃ³mo trabajar con parÃ¡metros y valores de retorno. ğŸš€

---

## ğŸ“Œ Â¿QuÃ© es una funciÃ³n en JavaScript?

Una **funciÃ³n** en JavaScript es un bloque de cÃ³digo diseÃ±ado para realizar una tarea especÃ­fica que puede ser ejecutado cuando se le "llama" o invoca. Las funciones son objetos de primera clase, lo que significa que pueden ser asignadas a variables, pasadas como argumentos, retornadas desde otras funciones y mÃ¡s.

!!! tip
    Las funciones no solo ejecutan cÃ³digo, sino que tambiÃ©n pueden devolver valores y ser utilizadas para estructurar programas de manera modular.

---

## ğŸ› ï¸ Formas de declarar funciones

Existen varias formas de definir funciones en JavaScript, cada una con sus caracterÃ­sticas y casos de uso. A continuaciÃ³n, exploraremos las mÃ¡s comunes:

### 1. **DeclaraciÃ³n de funciÃ³n** (Function Declaration)

La forma mÃ¡s tradicional de definir una funciÃ³n es mediante una **declaraciÃ³n de funciÃ³n**. Estas funciones son **hoisted** (elevadas), lo que significa que pueden ser invocadas antes de su definiciÃ³n en el cÃ³digo.

```javascript
function saludar(nombre) {
    return `Â¡Hola, ${nombre}!`;
}

console.log(saludar("Ana")); // Â¡Hola, Ana!
```

!!! note
    El **hoisting** permite que las declaraciones de funciones sean accesibles en todo el Ã¡mbito donde se definen, incluso antes de que aparezcan en el cÃ³digo.

### 2. **ExpresiÃ³n de funciÃ³n** (Function Expression)

Una **expresiÃ³n de funciÃ³n** asigna una funciÃ³n a una variable. A diferencia de las declaraciones, estas no son hoisted, por lo que deben definirse antes de usarse.

```javascript
const despedirse = function(nombre) {
    return `Â¡AdiÃ³s, ${nombre}!`;
};

console.log(despedirse("Juan")); // Â¡AdiÃ³s, Juan!
```

!!! tip
    Las expresiones de funciÃ³n son Ãºtiles cuando necesitas asignar funciones a variables o pasarlas como argumentos a otras funciones.

### 3. **Funciones flecha** (Arrow Functions)

Introducidas en **ES6**, las funciones flecha ofrecen una sintaxis mÃ¡s concisa y tienen un comportamiento especial con el contexto de `this`.

```javascript
const sumar = (a, b) => a + b;

console.log(sumar(5, 3)); // 8
```

!!! warning
    Las funciones flecha **no tienen su propio `this`**, lo que las hace ideales para callbacks, pero cuidado al usarlas en objetos donde el contexto de `this` es importante.

### 4. **Funciones anÃ³nimas**

Las funciones anÃ³nimas no tienen un nombre y suelen usarse como argumentos en otras funciones o en expresiones.

```javascript
setTimeout(function() {
    console.log("Â¡Han pasado 2 segundos!");
}, 2000);
```

### 5. **Funciones inmediatamente invocadas (IIFE)**

Una **IIFE** (Immediately Invoked Function Expression) es una funciÃ³n que se ejecuta inmediatamente despuÃ©s de definirse.

```javascript
(function() {
    console.log("Â¡Me ejecutÃ© al instante!");
})();
```

!!! success
    Las IIFE son Ãºtiles para crear un Ã¡mbito aislado y evitar contaminar el Ã¡mbito global.

---

## ğŸ” ParÃ¡metros y argumentos

Las funciones pueden recibir **parÃ¡metros**, que son variables definidas en la declaraciÃ³n de la funciÃ³n, y **argumentos**, que son los valores que se pasan al invocar la funciÃ³n.

### **ParÃ¡metros por defecto**

Desde **ES6**, puedes asignar valores por defecto a los parÃ¡metros.

```javascript
function saludar(nombre = "Invitado") {
    return `Â¡Hola, ${nombre}!`;
}

console.log(saludar()); // Â¡Hola, Invitado!
console.log(saludar("LucÃ­a")); // Â¡Hola, LucÃ­a!
```

### **ParÃ¡metro rest (`...`)**

El operador **rest** permite pasar un nÃºmero indefinido de argumentos como un arreglo.

```javascript
function sumarTodo(...numeros) {
    return numeros.reduce((total, num) => total + num, 0);
}

console.log(sumarTodo(1, 2, 3, 4)); // 10
```

### **ParÃ¡metros nombrados con objetos**

Puedes pasar un objeto como parÃ¡metro para manejar mÃºltiples valores de forma mÃ¡s organizada.

```javascript
function configurarUsuario({ nombre, edad, email }) {
    return `Usuario: ${nombre}, Edad: ${edad}, Email: ${email}`;
}

console.log(configurarUsuario({ nombre: "Ana", edad: 25, email: "ana@example.com" }));
```

!!! tip
    Los parÃ¡metros nombrados mejoran la legibilidad y flexibilidad al trabajar con mÃºltiples argumentos.

---

## ğŸ“¤ Valor de retorno

Las funciones pueden devolver un valor usando la palabra clave `return`. Si no se especifica, la funciÃ³n devuelve `undefined` por defecto.

```javascript
function multiplicar(a, b) {
    return a * b;
}

console.log(multiplicar(4, 5)); // 20
```

!!! note
    Todo lo que se escriba despuÃ©s de `return` no se ejecutarÃ¡, ya que la funciÃ³n termina su ejecuciÃ³n en ese punto.

---

## ğŸŒ Ãmbito y closure

### **Ãmbito (Scope)**

El **Ã¡mbito** determina dÃ³nde una variable es accesible. JavaScript tiene dos tipos principales de Ã¡mbito:

- **Ãmbito global**: Variables definidas fuera de cualquier funciÃ³n.
- **Ãmbito local**: Variables definidas dentro de una funciÃ³n.

```javascript
let global = "Soy global";

function miFuncion() {
    let local = "Soy local";
    console.log(global); // Accesible
    console.log(local); // Accesible
}

console.log(global); // Accesible
// console.log(local); // Error: local is not defined
```

### **Closure**

Un **closure** ocurre cuando una funciÃ³n interna tiene acceso a las variables de su funciÃ³n externa, incluso despuÃ©s de que la funciÃ³n externa haya terminado de ejecutarse.

```javascript
function crearContador() {
    let contador = 0;
    return function() {
        return contador++;
    };
}

const contador1 = crearContador();
console.log(contador1()); // 0
console.log(contador1()); // 1
```

!!! success
    Los closures son ideales para crear funciones con estado privado, como contadores o mÃ³dulos.

---

## ğŸ”§ Ejemplos prÃ¡cticos

### **Calculadora bÃ¡sica con funciones**

```javascript
// Funciones para operaciones bÃ¡sicas
function sumar(a, b) {
    return a + b;
}

function restar(a, b) {
    return a - b;
}

function multiplicar(a, b) {
    return a * b;
}

function dividir(a, b) {
    if (b === 0) {
        return "Error: DivisiÃ³n por cero";
    }
    return a / b;
}

// FunciÃ³n principal de la calculadora
function calculadora(operacion, num1, num2) {
    switch(operacion) {
        case 'suma':
            return sumar(num1, num2);
        case 'resta':
            return restar(num1, num2);
        case 'multiplicacion':
            return multiplicar(num1, num2);
        case 'division':
            return dividir(num1, num2);
        default:
            return "OperaciÃ³n no vÃ¡lida";
    }
}

console.log(calculadora('suma', 10, 5)); // 15
console.log(calculadora('division', 10, 0)); // Error: DivisiÃ³n por cero
```

### **Validador de datos**

```javascript
// FunciÃ³n para validar email
function validarEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

// FunciÃ³n para validar contraseÃ±a
function validarContrasena(contrasena) {
    return contrasena.length >= 8;
}

// FunciÃ³n para validar edad
function validarEdad(edad) {
    return edad >= 18 && edad <= 120;
}

// FunciÃ³n principal de validaciÃ³n
function validarUsuario(datos) {
    const errores = [];
    
    if (!validarEmail(datos.email)) {
        errores.push("Email no vÃ¡lido");
    }
    
    if (!validarContrasena(datos.contrasena)) {
        errores.push("La contraseÃ±a debe tener al menos 8 caracteres");
    }
    
    if (!validarEdad(datos.edad)) {
        errores.push("La edad debe estar entre 18 y 120 aÃ±os");
    }
    
    return {
        valido: errores.length === 0,
        errores: errores
    };
}

const usuario = {
    email: "juan@example.com",
    contrasena: "mipassword123",
    edad: 25
};

console.log(validarUsuario(usuario));
```

---

## ğŸ›‘ Buenas prÃ¡cticas

1. **Nombra tus funciones de manera clara** para reflejar su propÃ³sito.
2. **Evita funciones demasiado largas**. Divide el cÃ³digo en funciones mÃ¡s pequeÃ±as.
3. **Usa parÃ¡metros por defecto** para manejar casos no definidos.
4. **Documenta tus funciones** con comentarios explicativos.
5. **Valida los parÃ¡metros** antes de procesarlos.
6. **Usa nombres descriptivos** para parÃ¡metros y variables.
7. **Evita efectos secundarios** innecesarios.
8. **Retorna valores consistentes** del mismo tipo.

!!! tip "Consejo profesional"
    Una funciÃ³n debe hacer una sola cosa y hacerla bien. Si tu funciÃ³n tiene mÃ¡s de 20 lÃ­neas, probablemente deberÃ­a dividirse en funciones mÃ¡s pequeÃ±as.

---

## ğŸ“š Ejercicios de prÃ¡ctica

### **Ejercicio 1: Conversor de temperatura**

Crea funciones para convertir entre Celsius, Fahrenheit y Kelvin.

```javascript
// Tu cÃ³digo aquÃ­
function celsiusAFahrenheit(celsius) {
    // Implementar
}

function fahrenheitACelsius(fahrenheit) {
    // Implementar
}

function celsiusAKelvin(celsius) {
    // Implementar
}
```

### **Ejercicio 2: Generador de contraseÃ±as**

Crea una funciÃ³n que genere contraseÃ±as aleatorias con diferentes opciones.

```javascript
// Tu cÃ³digo aquÃ­
function generarContrasena(longitud = 8, incluirMayusculas = true, incluirNumeros = true, incluirSimbolos = false) {
    // Implementar
}
```

### **Ejercicio 3: Calculadora de IMC**

Crea funciones para calcular el Ãndice de Masa Corporal y clasificar el resultado.

```javascript
// Tu cÃ³digo aquÃ­
function calcularIMC(peso, altura) {
    // Implementar
}

function clasificarIMC(imc) {
    // Implementar
}
```

!!! note "PrÃ³xima semana"
    En la **Semana 5** exploraremos conceptos avanzados de funciones como closures, funciones de orden superior, mÃ©todos de funciones y patrones avanzados de programaciÃ³n funcional.

---
