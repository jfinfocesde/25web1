#  Semana 4 - Fundamentos de Funciones en JavaScript

!!! info "Introducción"
    Las **funciones** son uno de los pilares fundamentales de JavaScript, un lenguaje de programación dinámico y versátil. Las funciones permiten encapsular bloques de código reutilizables, facilitando la organización, modularidad y mantenimiento del código. En esta semana, exploraremos los conceptos básicos de las funciones: qué son, cómo se definen, sus diferentes tipos y cómo trabajar con parámetros y valores de retorno. 🚀

---

## 📌 ¿Qué es una función en JavaScript?

Una **función** en JavaScript es un bloque de código diseñado para realizar una tarea específica que puede ser ejecutado cuando se le "llama" o invoca. Las funciones son objetos de primera clase, lo que significa que pueden ser asignadas a variables, pasadas como argumentos, retornadas desde otras funciones y más.

!!! tip
    Las funciones no solo ejecutan código, sino que también pueden devolver valores y ser utilizadas para estructurar programas de manera modular.

---

## 🛠️ Formas de declarar funciones

Existen varias formas de definir funciones en JavaScript, cada una con sus características y casos de uso. A continuación, exploraremos las más comunes:

### 1. **Declaración de función** (Function Declaration)

La forma más tradicional de definir una función es mediante una **declaración de función**. Estas funciones son **hoisted** (elevadas), lo que significa que pueden ser invocadas antes de su definición en el código.

```javascript
function saludar(nombre) {
    return `¡Hola, ${nombre}!`;
}

console.log(saludar("Ana")); // ¡Hola, Ana!
```

!!! note
    El **hoisting** permite que las declaraciones de funciones sean accesibles en todo el ámbito donde se definen, incluso antes de que aparezcan en el código.

### 2. **Expresión de función** (Function Expression)

Una **expresión de función** asigna una función a una variable. A diferencia de las declaraciones, estas no son hoisted, por lo que deben definirse antes de usarse.

```javascript
const despedirse = function(nombre) {
    return `¡Adiós, ${nombre}!`;
};

console.log(despedirse("Juan")); // ¡Adiós, Juan!
```

!!! tip
    Las expresiones de función son útiles cuando necesitas asignar funciones a variables o pasarlas como argumentos a otras funciones.

### 3. **Funciones flecha** (Arrow Functions)

Introducidas en **ES6**, las funciones flecha ofrecen una sintaxis más concisa y tienen un comportamiento especial con el contexto de `this`.

```javascript
const sumar = (a, b) => a + b;

console.log(sumar(5, 3)); // 8
```

!!! warning
    Las funciones flecha **no tienen su propio `this`**, lo que las hace ideales para callbacks, pero cuidado al usarlas en objetos donde el contexto de `this` es importante.

### 4. **Funciones anónimas**

Las funciones anónimas no tienen un nombre y suelen usarse como argumentos en otras funciones o en expresiones.

```javascript
setTimeout(function() {
    console.log("¡Han pasado 2 segundos!");
}, 2000);
```

### 5. **Funciones inmediatamente invocadas (IIFE)**

Una **IIFE** (Immediately Invoked Function Expression) es una función que se ejecuta inmediatamente después de definirse.

```javascript
(function() {
    console.log("¡Me ejecuté al instante!");
})();
```

!!! success
    Las IIFE son útiles para crear un ámbito aislado y evitar contaminar el ámbito global.

---

## 🔍 Parámetros y argumentos

Las funciones pueden recibir **parámetros**, que son variables definidas en la declaración de la función, y **argumentos**, que son los valores que se pasan al invocar la función.

### **Parámetros por defecto**

Desde **ES6**, puedes asignar valores por defecto a los parámetros.

```javascript
function saludar(nombre = "Invitado") {
    return `¡Hola, ${nombre}!`;
}

console.log(saludar()); // ¡Hola, Invitado!
console.log(saludar("Lucía")); // ¡Hola, Lucía!
```

### **Parámetro rest (`...`)**

El operador **rest** permite pasar un número indefinido de argumentos como un arreglo.

```javascript
function sumarTodo(...numeros) {
    return numeros.reduce((total, num) => total + num, 0);
}

console.log(sumarTodo(1, 2, 3, 4)); // 10
```

### **Parámetros nombrados con objetos**

Puedes pasar un objeto como parámetro para manejar múltiples valores de forma más organizada.

```javascript
function configurarUsuario({ nombre, edad, email }) {
    return `Usuario: ${nombre}, Edad: ${edad}, Email: ${email}`;
}

console.log(configurarUsuario({ nombre: "Ana", edad: 25, email: "ana@example.com" }));
```

!!! tip
    Los parámetros nombrados mejoran la legibilidad y flexibilidad al trabajar con múltiples argumentos.

---

## 📤 Valor de retorno

Las funciones pueden devolver un valor usando la palabra clave `return`. Si no se especifica, la función devuelve `undefined` por defecto.

```javascript
function multiplicar(a, b) {
    return a * b;
}

console.log(multiplicar(4, 5)); // 20
```

!!! note
    Todo lo que se escriba después de `return` no se ejecutará, ya que la función termina su ejecución en ese punto.

---

## 🌐 Ámbito y closure

### **Ámbito (Scope)**

El **ámbito** determina dónde una variable es accesible. JavaScript tiene dos tipos principales de ámbito:

- **Ámbito global**: Variables definidas fuera de cualquier función.
- **Ámbito local**: Variables definidas dentro de una función.

```javascript
let global = "Soy global";

function miFuncion() {
    let local = "Soy local";
    console.log(global); // Accesible
    console.log(local); // Accesible
}

console.log(global); // Accesible
// console.log(local); // Error: local is not defined
```

### **Closure**

Un **closure** ocurre cuando una función interna tiene acceso a las variables de su función externa, incluso después de que la función externa haya terminado de ejecutarse.

```javascript
function crearContador() {
    let contador = 0;
    return function() {
        return contador++;
    };
}

const contador1 = crearContador();
console.log(contador1()); // 0
console.log(contador1()); // 1
```

!!! success
    Los closures son ideales para crear funciones con estado privado, como contadores o módulos.

---

## 🔧 Ejemplos prácticos

### **Calculadora básica con funciones**

```javascript
// Funciones para operaciones básicas
function sumar(a, b) {
    return a + b;
}

function restar(a, b) {
    return a - b;
}

function multiplicar(a, b) {
    return a * b;
}

function dividir(a, b) {
    if (b === 0) {
        return "Error: División por cero";
    }
    return a / b;
}

// Función principal de la calculadora
function calculadora(operacion, num1, num2) {
    switch(operacion) {
        case 'suma':
            return sumar(num1, num2);
        case 'resta':
            return restar(num1, num2);
        case 'multiplicacion':
            return multiplicar(num1, num2);
        case 'division':
            return dividir(num1, num2);
        default:
            return "Operación no válida";
    }
}

console.log(calculadora('suma', 10, 5)); // 15
console.log(calculadora('division', 10, 0)); // Error: División por cero
```

### **Validador de datos**

```javascript
// Función para validar email
function validarEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

// Función para validar contraseña
function validarContrasena(contrasena) {
    return contrasena.length >= 8;
}

// Función para validar edad
function validarEdad(edad) {
    return edad >= 18 && edad <= 120;
}

// Función principal de validación
function validarUsuario(datos) {
    const errores = [];
    
    if (!validarEmail(datos.email)) {
        errores.push("Email no válido");
    }
    
    if (!validarContrasena(datos.contrasena)) {
        errores.push("La contraseña debe tener al menos 8 caracteres");
    }
    
    if (!validarEdad(datos.edad)) {
        errores.push("La edad debe estar entre 18 y 120 años");
    }
    
    return {
        valido: errores.length === 0,
        errores: errores
    };
}

const usuario = {
    email: "juan@example.com",
    contrasena: "mipassword123",
    edad: 25
};

console.log(validarUsuario(usuario));
```

---

## 🛑 Buenas prácticas

1. **Nombra tus funciones de manera clara** para reflejar su propósito.
2. **Evita funciones demasiado largas**. Divide el código en funciones más pequeñas.
3. **Usa parámetros por defecto** para manejar casos no definidos.
4. **Documenta tus funciones** con comentarios explicativos.
5. **Valida los parámetros** antes de procesarlos.
6. **Usa nombres descriptivos** para parámetros y variables.
7. **Evita efectos secundarios** innecesarios.
8. **Retorna valores consistentes** del mismo tipo.

!!! tip "Consejo profesional"
    Una función debe hacer una sola cosa y hacerla bien. Si tu función tiene más de 20 líneas, probablemente debería dividirse en funciones más pequeñas.

---

## 📚 Ejercicios de práctica

### **Ejercicio 1: Conversor de temperatura**

Crea funciones para convertir entre Celsius, Fahrenheit y Kelvin.

```javascript
// Tu código aquí
function celsiusAFahrenheit(celsius) {
    // Implementar
}

function fahrenheitACelsius(fahrenheit) {
    // Implementar
}

function celsiusAKelvin(celsius) {
    // Implementar
}
```

### **Ejercicio 2: Generador de contraseñas**

Crea una función que genere contraseñas aleatorias con diferentes opciones.

```javascript
// Tu código aquí
function generarContrasena(longitud = 8, incluirMayusculas = true, incluirNumeros = true, incluirSimbolos = false) {
    // Implementar
}
```

### **Ejercicio 3: Calculadora de IMC**

Crea funciones para calcular el Índice de Masa Corporal y clasificar el resultado.

```javascript
// Tu código aquí
function calcularIMC(peso, altura) {
    // Implementar
}

function clasificarIMC(imc) {
    // Implementar
}
```

!!! note "Próxima semana"
    En la **Semana 5** exploraremos conceptos avanzados de funciones como closures, funciones de orden superior, métodos de funciones y patrones avanzados de programación funcional.

---
