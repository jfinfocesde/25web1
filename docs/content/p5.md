#  Semana 5 - Funciones Avanzadas en JavaScript

!!! info "Introducci贸n"
    En esta semana profundizaremos en los conceptos avanzados de las funciones en JavaScript. Exploraremos closures, funciones de orden superior, m茅todos de funciones, recursividad, y patrones avanzados de programaci贸n funcional que te permitir谩n escribir c贸digo m谩s elegante y eficiente. 

---

## 锔 Funciones como objetos de primera clase

En JavaScript, las funciones son **objetos de primera clase**, lo que significa que pueden:

- Ser asignadas a variables.
- Ser pasadas como argumentos.
- Ser devueltas por otras funciones.
- Tener propiedades y m茅todos.

```javascript
function operacion(a, b, callback) {
    return callback(a, b);
}

const suma = (a, b) => a + b;
const multiplicacion = (a, b) => a * b;

console.log(operacion(5, 3, suma)); // 8
console.log(operacion(5, 3, multiplicacion)); // 15

// Las funciones pueden tener propiedades
suma.descripcion = "Funci贸n que suma dos n煤meros";
console.log(suma.descripcion);
```

!!! tip
    Esta caracter铆stica hace que JavaScript sea extremadamente flexible para la programaci贸n funcional y el desarrollo de patrones avanzados.

---

##  Closures (Clausuras)

Un **closure** es una caracter铆stica poderosa que permite a una funci贸n acceder a variables de su 谩mbito externo, incluso despu茅s de que la funci贸n externa haya terminado de ejecutarse.

### **Ejemplo b谩sico de closure**

```javascript
function crearContador() {
    let contador = 0;
    
    return function() {
        contador++;
        return contador;
    };
}

const contador1 = crearContador();
const contador2 = crearContador();

console.log(contador1()); // 1
console.log(contador1()); // 2
console.log(contador2()); // 1 (independiente)
console.log(contador1()); // 3
```

### **Closure con par谩metros**

```javascript
function crearMultiplicador(factor) {
    return function(numero) {
        return numero * factor;
    };
}

const duplicar = crearMultiplicador(2);
const triplicar = crearMultiplicador(3);

console.log(duplicar(5)); // 10
console.log(triplicar(5)); // 15
```

### **Patr贸n m贸dulo con closures**

```javascript
const calculadoraAvanzada = (function() {
    let historial = [];
    
    return {
        sumar: function(a, b) {
            const resultado = a + b;
            historial.push(`${a} + ${b} = ${resultado}`);
            return resultado;
        },
        
        restar: function(a, b) {
            const resultado = a - b;
            historial.push(`${a} - ${b} = ${resultado}`);
            return resultado;
        },
        
        obtenerHistorial: function() {
            return [...historial]; // Copia del historial
        },
        
        limpiarHistorial: function() {
            historial = [];
        }
    };
})();

console.log(calculadoraAvanzada.sumar(5, 3)); // 8
console.log(calculadoraAvanzada.restar(10, 4)); // 6
console.log(calculadoraAvanzada.obtenerHistorial());
```

!!! success
    Los closures son fundamentales para crear m贸dulos, mantener estado privado y implementar patrones como el patr贸n factory.

---

##  Funciones de orden superior

Una **funci贸n de orden superior** es aquella que:
- Recibe una o m谩s funciones como argumentos
- Devuelve una funci贸n como resultado
- O ambas

### **M茅todos de array como funciones de orden superior**

```javascript
const numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// filter - filtra elementos
const pares = numeros.filter(num => num % 2 === 0);
console.log(pares); // [2, 4, 6, 8, 10]

// map - transforma elementos
const cuadrados = numeros.map(num => num ** 2);
console.log(cuadrados); // [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

// reduce - reduce a un solo valor
const suma = numeros.reduce((acc, num) => acc + num, 0);
console.log(suma); // 55

// Combinando m茅todos
const sumaCuadradosPares = numeros
    .filter(num => num % 2 === 0)
    .map(num => num ** 2)
    .reduce((acc, num) => acc + num, 0);
    
console.log(sumaCuadradosPares); // 220
```

### **Creando nuestras propias funciones de orden superior**

```javascript
// Funci贸n que aplica una operaci贸n a todos los elementos
function aplicarOperacion(array, operacion) {
    const resultado = [];
    for (let i = 0; i < array.length; i++) {
        resultado.push(operacion(array[i]));
    }
    return resultado;
}

// Funci贸n que crea validadores
function crearValidador(condicion, mensaje) {
    return function(valor) {
        if (condicion(valor)) {
            return { valido: true };
        } else {
            return { valido: false, mensaje: mensaje };
        }
    };
}

const validarEdad = crearValidador(
    edad => edad >= 18 && edad <= 120,
    "La edad debe estar entre 18 y 120 a帽os"
);

const validarEmail = crearValidador(
    email => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
    "El email no tiene un formato v谩lido"
);

console.log(validarEdad(25)); // { valido: true }
console.log(validarEmail("test")); // { valido: false, mensaje: "..." }
```

---

##  M茅todos de funciones

Las funciones en JavaScript tienen m茅todos integrados que permiten controlar su contexto de ejecuci贸n.

### **call(), apply() y bind()**

```javascript
const persona1 = { nombre: "Ana", edad: 25 };
const persona2 = { nombre: "Carlos", edad: 30 };

function presentarse(saludo, profesion) {
    return `${saludo}, soy ${this.nombre}, tengo ${this.edad} a帽os y soy ${profesion}`;
}

// call() - argumentos separados
console.log(presentarse.call(persona1, "Hola", "desarrolladora"));
// "Hola, soy Ana, tengo 25 a帽os y soy desarrolladora"

// apply() - argumentos en array
console.log(presentarse.apply(persona2, ["Buenos d铆as", "dise帽ador"]));
// "Buenos d铆as, soy Carlos, tengo 30 a帽os y soy dise帽ador"

// bind() - crea una nueva funci贸n con contexto fijo
const presentarAna = presentarse.bind(persona1);
console.log(presentarAna("Saludos", "programadora"));
// "Saludos, soy Ana, tengo 25 a帽os y soy programadora"
```

### **Uso pr谩ctico con eventos**

```javascript
class Contador {
    constructor() {
        this.valor = 0;
    }
    
    incrementar() {
        this.valor++;
        console.log(`Contador: ${this.valor}`);
    }
    
    configurarBoton(botonId) {
        const boton = document.getElementById(botonId);
        // Sin bind, 'this' ser铆a el bot贸n, no el contador
        boton.addEventListener('click', this.incrementar.bind(this));
    }
}
```

---

##  Funciones recursivas

Una funci贸n recursiva se llama a s铆 misma para resolver un problema dividi茅ndolo en subproblemas m谩s peque帽os.

### **Ejemplos cl谩sicos**

```javascript
// Factorial
function factorial(n) {
    // Caso base
    if (n <= 1) return 1;
    // Caso recursivo
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 120

// Fibonacci
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(10)); // 55

// Fibonacci optimizado con memoizaci贸n
function fibonacciMemo(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 1) return n;
    
    memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    return memo[n];
}

console.log(fibonacciMemo(50)); // Mucho m谩s r谩pido
```

### **Recursi贸n con estructuras de datos**

```javascript
// Recorrer un 谩rbol de directorios
const estructura = {
    nombre: "proyecto",
    tipo: "carpeta",
    contenido: [
        {
            nombre: "src",
            tipo: "carpeta",
            contenido: [
                { nombre: "index.js", tipo: "archivo" },
                { nombre: "utils.js", tipo: "archivo" }
            ]
        },
        { nombre: "README.md", tipo: "archivo" }
    ]
};

function listarArchivos(estructura, nivel = 0) {
    const indentacion = "  ".repeat(nivel);
    console.log(`${indentacion}${estructura.nombre}`);
    
    if (estructura.contenido) {
        estructura.contenido.forEach(item => {
            listarArchivos(item, nivel + 1);
        });
    }
}

listarArchivos(estructura);
```

---

##  Programaci贸n funcional

### **Funciones puras**

Una funci贸n pura:
- Siempre devuelve el mismo resultado para los mismos argumentos
- No tiene efectos secundarios

```javascript
// Funci贸n pura
function sumarPuro(a, b) {
    return a + b;
}

// Funci贸n impura (modifica estado externo)
let contador = 0;
function sumarImpuro(a, b) {
    contador++; // Efecto secundario
    return a + b;
}
```

### **Composici贸n de funciones**

```javascript
// Funciones simples
const duplicar = x => x * 2;
const sumarUno = x => x + 1;
const elevarAlCuadrado = x => x ** 2;

// Composici贸n manual
const resultado1 = elevarAlCuadrado(sumarUno(duplicar(3)));
console.log(resultado1); // 49

// Funci贸n para componer
function componer(...funciones) {
    return function(valor) {
        return funciones.reduceRight((acc, fn) => fn(acc), valor);
    };
}

const operacionCompuesta = componer(elevarAlCuadrado, sumarUno, duplicar);
console.log(operacionCompuesta(3)); // 49
```

### **Currying**

```javascript
// Funci贸n normal
function multiplicar(a, b, c) {
    return a * b * c;
}

// Funci贸n currificada
function multiplicarCurry(a) {
    return function(b) {
        return function(c) {
            return a * b * c;
        };
    };
}

// Uso
const multiplicarPor2 = multiplicarCurry(2);
const multiplicarPor2Y3 = multiplicarPor2(3);
console.log(multiplicarPor2Y3(4)); // 24

// Versi贸n con arrow functions
const multiplicarCurryArrow = a => b => c => a * b * c;
console.log(multiplicarCurryArrow(2)(3)(4)); // 24
```

---

##  Patrones avanzados

### **Patr贸n Factory**

```javascript
function crearUsuario(nombre, email, rol = 'usuario') {
    return {
        nombre,
        email,
        rol,
        activo: true,
        
        activar() {
            this.activo = true;
            return this;
        },
        
        desactivar() {
            this.activo = false;
            return this;
        },
        
        cambiarRol(nuevoRol) {
            this.rol = nuevoRol;
            return this;
        },
        
        obtenerInfo() {
            return `${this.nombre} (${this.email}) - ${this.rol} - ${this.activo ? 'Activo' : 'Inactivo'}`;
        }
    };
}

const usuario = crearUsuario("Ana", "ana@example.com")
    .cambiarRol("admin")
    .activar();
    
console.log(usuario.obtenerInfo());
```

### **Patr贸n Observer con funciones**

```javascript
function crearObservable() {
    let observadores = [];
    
    return {
        suscribir(callback) {
            observadores.push(callback);
            
            // Retorna funci贸n para desuscribirse
            return function desuscribir() {
                observadores = observadores.filter(obs => obs !== callback);
            };
        },
        
        notificar(datos) {
            observadores.forEach(callback => callback(datos));
        }
    };
}

const evento = crearObservable();

const desuscribir1 = evento.suscribir(datos => console.log("Observer 1:", datos));
const desuscribir2 = evento.suscribir(datos => console.log("Observer 2:", datos));

evento.notificar("隆Hola mundo!"); // Ambos observadores reciben el mensaje

desuscribir1(); // Desuscribe el primer observador
evento.notificar("Solo el segundo observador ver谩 esto");
```

---

##  Buenas pr谩cticas avanzadas

1. **Prefiere funciones puras** cuando sea posible
2. **Usa closures para encapsular estado privado**
3. **Aprovecha las funciones de orden superior** para c贸digo m谩s expresivo
4. **Evita la recursi贸n profunda** sin optimizaci贸n
5. **Usa memoizaci贸n** para optimizar funciones costosas
6. **Comp贸n funciones peque帽as** en lugar de crear funciones grandes
7. **Documenta el comportamiento de closures** y contexto
8. **Considera el rendimiento** al usar m茅todos de array encadenados

!!! warning "Cuidado con la recursi贸n"
    JavaScript no optimiza la recursi贸n de cola, por lo que recursiones muy profundas pueden causar stack overflow. Considera usar iteraci贸n o trampolining para casos extremos.

---

##  Ejercicios avanzados

### **Ejercicio 1: Sistema de cache con closures**

```javascript
// Implementa una funci贸n que cree un sistema de cache
function crearCache(tiempoExpiracion = 60000) {
    // Tu c贸digo aqu铆
    // Debe retornar un objeto con m茅todos get, set, clear
}
```

### **Ejercicio 2: Funci贸n de debounce**

```javascript
// Implementa una funci贸n debounce que retrase la ejecuci贸n
function debounce(func, delay) {
    // Tu c贸digo aqu铆
}
```

### **Ejercicio 3: Pipeline de transformaciones**

```javascript
// Crea una funci贸n que permita encadenar transformaciones
function pipeline(...funciones) {
    // Tu c贸digo aqu铆
}

// Uso esperado:
// const transformar = pipeline(duplicar, sumarUno, elevarAlCuadrado);
// console.log(transformar(3)); // 49
```


