#  Semana 5 - Funciones Avanzadas en JavaScript

!!! info "Introducción"
    En esta semana profundizaremos en los conceptos avanzados de las funciones en JavaScript. Exploraremos closures, funciones de orden superior, métodos de funciones, recursividad, y patrones avanzados de programación funcional que te permitirán escribir código más elegante y eficiente. 🚀

---

## ⚙️ Funciones como objetos de primera clase

En JavaScript, las funciones son **objetos de primera clase**, lo que significa que pueden:

- Ser asignadas a variables.
- Ser pasadas como argumentos.
- Ser devueltas por otras funciones.
- Tener propiedades y métodos.

```javascript
function operacion(a, b, callback) {
    return callback(a, b);
}

const suma = (a, b) => a + b;
const multiplicacion = (a, b) => a * b;

console.log(operacion(5, 3, suma)); // 8
console.log(operacion(5, 3, multiplicacion)); // 15

// Las funciones pueden tener propiedades
suma.descripcion = "Función que suma dos números";
console.log(suma.descripcion);
```

!!! tip
    Esta característica hace que JavaScript sea extremadamente flexible para la programación funcional y el desarrollo de patrones avanzados.

---

## 🔄 Closures (Clausuras)

Un **closure** es una característica poderosa que permite a una función acceder a variables de su ámbito externo, incluso después de que la función externa haya terminado de ejecutarse.

### **Ejemplo básico de closure**

```javascript
function crearContador() {
    let contador = 0;
    
    return function() {
        contador++;
        return contador;
    };
}

const contador1 = crearContador();
const contador2 = crearContador();

console.log(contador1()); // 1
console.log(contador1()); // 2
console.log(contador2()); // 1 (independiente)
console.log(contador1()); // 3
```

### **Closure con parámetros**

```javascript
function crearMultiplicador(factor) {
    return function(numero) {
        return numero * factor;
    };
}

const duplicar = crearMultiplicador(2);
const triplicar = crearMultiplicador(3);

console.log(duplicar(5)); // 10
console.log(triplicar(5)); // 15
```

### **Patrón módulo con closures**

```javascript
const calculadoraAvanzada = (function() {
    let historial = [];
    
    return {
        sumar: function(a, b) {
            const resultado = a + b;
            historial.push(`${a} + ${b} = ${resultado}`);
            return resultado;
        },
        
        restar: function(a, b) {
            const resultado = a - b;
            historial.push(`${a} - ${b} = ${resultado}`);
            return resultado;
        },
        
        obtenerHistorial: function() {
            return [...historial]; // Copia del historial
        },
        
        limpiarHistorial: function() {
            historial = [];
        }
    };
})();

console.log(calculadoraAvanzada.sumar(5, 3)); // 8
console.log(calculadoraAvanzada.restar(10, 4)); // 6
console.log(calculadoraAvanzada.obtenerHistorial());
```

!!! success
    Los closures son fundamentales para crear módulos, mantener estado privado y implementar patrones como el patrón factory.

---

## 🎨 Funciones de orden superior

Una **función de orden superior** es aquella que:
- Recibe una o más funciones como argumentos
- Devuelve una función como resultado
- O ambas

### **Métodos de array como funciones de orden superior**

```javascript
const numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// filter - filtra elementos
const pares = numeros.filter(num => num % 2 === 0);
console.log(pares); // [2, 4, 6, 8, 10]

// map - transforma elementos
const cuadrados = numeros.map(num => num ** 2);
console.log(cuadrados); // [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

// reduce - reduce a un solo valor
const suma = numeros.reduce((acc, num) => acc + num, 0);
console.log(suma); // 55

// Combinando métodos
const sumaCuadradosPares = numeros
    .filter(num => num % 2 === 0)
    .map(num => num ** 2)
    .reduce((acc, num) => acc + num, 0);
    
console.log(sumaCuadradosPares); // 220
```

### **Creando nuestras propias funciones de orden superior**

```javascript
// Función que aplica una operación a todos los elementos
function aplicarOperacion(array, operacion) {
    const resultado = [];
    for (let i = 0; i < array.length; i++) {
        resultado.push(operacion(array[i]));
    }
    return resultado;
}

// Función que crea validadores
function crearValidador(condicion, mensaje) {
    return function(valor) {
        if (condicion(valor)) {
            return { valido: true };
        } else {
            return { valido: false, mensaje: mensaje };
        }
    };
}

const validarEdad = crearValidador(
    edad => edad >= 18 && edad <= 120,
    "La edad debe estar entre 18 y 120 años"
);

const validarEmail = crearValidador(
    email => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
    "El email no tiene un formato válido"
);

console.log(validarEdad(25)); // { valido: true }
console.log(validarEmail("test")); // { valido: false, mensaje: "..." }
```

---

## 🔧 Métodos de funciones

Las funciones en JavaScript tienen métodos integrados que permiten controlar su contexto de ejecución.

### **call(), apply() y bind()**

```javascript
const persona1 = { nombre: "Ana", edad: 25 };
const persona2 = { nombre: "Carlos", edad: 30 };

function presentarse(saludo, profesion) {
    return `${saludo}, soy ${this.nombre}, tengo ${this.edad} años y soy ${profesion}`;
}

// call() - argumentos separados
console.log(presentarse.call(persona1, "Hola", "desarrolladora"));
// "Hola, soy Ana, tengo 25 años y soy desarrolladora"

// apply() - argumentos en array
console.log(presentarse.apply(persona2, ["Buenos días", "diseñador"]));
// "Buenos días, soy Carlos, tengo 30 años y soy diseñador"

// bind() - crea una nueva función con contexto fijo
const presentarAna = presentarse.bind(persona1);
console.log(presentarAna("Saludos", "programadora"));
// "Saludos, soy Ana, tengo 25 años y soy programadora"
```

### **Uso práctico con eventos**

```javascript
class Contador {
    constructor() {
        this.valor = 0;
    }
    
    incrementar() {
        this.valor++;
        console.log(`Contador: ${this.valor}`);
    }
    
    configurarBoton(botonId) {
        const boton = document.getElementById(botonId);
        // Sin bind, 'this' sería el botón, no el contador
        boton.addEventListener('click', this.incrementar.bind(this));
    }
}
```

---

## 🔄 Funciones recursivas

Una función recursiva se llama a sí misma para resolver un problema dividiéndolo en subproblemas más pequeños.

### **Ejemplos clásicos**

```javascript
// Factorial
function factorial(n) {
    // Caso base
    if (n <= 1) return 1;
    // Caso recursivo
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 120

// Fibonacci
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(10)); // 55

// Fibonacci optimizado con memoización
function fibonacciMemo(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 1) return n;
    
    memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    return memo[n];
}

console.log(fibonacciMemo(50)); // Mucho más rápido
```

### **Recursión con estructuras de datos**

```javascript
// Recorrer un árbol de directorios
const estructura = {
    nombre: "proyecto",
    tipo: "carpeta",
    contenido: [
        {
            nombre: "src",
            tipo: "carpeta",
            contenido: [
                { nombre: "index.js", tipo: "archivo" },
                { nombre: "utils.js", tipo: "archivo" }
            ]
        },
        { nombre: "README.md", tipo: "archivo" }
    ]
};

function listarArchivos(estructura, nivel = 0) {
    const indentacion = "  ".repeat(nivel);
    console.log(`${indentacion}${estructura.nombre}`);
    
    if (estructura.contenido) {
        estructura.contenido.forEach(item => {
            listarArchivos(item, nivel + 1);
        });
    }
}

listarArchivos(estructura);
```

---

## 🎯 Programación funcional

### **Funciones puras**

Una función pura:
- Siempre devuelve el mismo resultado para los mismos argumentos
- No tiene efectos secundarios

```javascript
// Función pura
function sumarPuro(a, b) {
    return a + b;
}

// Función impura (modifica estado externo)
let contador = 0;
function sumarImpuro(a, b) {
    contador++; // Efecto secundario
    return a + b;
}
```

### **Composición de funciones**

```javascript
// Funciones simples
const duplicar = x => x * 2;
const sumarUno = x => x + 1;
const elevarAlCuadrado = x => x ** 2;

// Composición manual
const resultado1 = elevarAlCuadrado(sumarUno(duplicar(3)));
console.log(resultado1); // 49

// Función para componer
function componer(...funciones) {
    return function(valor) {
        return funciones.reduceRight((acc, fn) => fn(acc), valor);
    };
}

const operacionCompuesta = componer(elevarAlCuadrado, sumarUno, duplicar);
console.log(operacionCompuesta(3)); // 49
```

### **Currying**

```javascript
// Función normal
function multiplicar(a, b, c) {
    return a * b * c;
}

// Función currificada
function multiplicarCurry(a) {
    return function(b) {
        return function(c) {
            return a * b * c;
        };
    };
}

// Uso
const multiplicarPor2 = multiplicarCurry(2);
const multiplicarPor2Y3 = multiplicarPor2(3);
console.log(multiplicarPor2Y3(4)); // 24

// Versión con arrow functions
const multiplicarCurryArrow = a => b => c => a * b * c;
console.log(multiplicarCurryArrow(2)(3)(4)); // 24
```

---

## 🚀 Patrones avanzados

### **Patrón Factory**

```javascript
function crearUsuario(nombre, email, rol = 'usuario') {
    return {
        nombre,
        email,
        rol,
        activo: true,
        
        activar() {
            this.activo = true;
            return this;
        },
        
        desactivar() {
            this.activo = false;
            return this;
        },
        
        cambiarRol(nuevoRol) {
            this.rol = nuevoRol;
            return this;
        },
        
        obtenerInfo() {
            return `${this.nombre} (${this.email}) - ${this.rol} - ${this.activo ? 'Activo' : 'Inactivo'}`;
        }
    };
}

const usuario = crearUsuario("Ana", "ana@example.com")
    .cambiarRol("admin")
    .activar();
    
console.log(usuario.obtenerInfo());
```

### **Patrón Observer con funciones**

```javascript
function crearObservable() {
    let observadores = [];
    
    return {
        suscribir(callback) {
            observadores.push(callback);
            
            // Retorna función para desuscribirse
            return function desuscribir() {
                observadores = observadores.filter(obs => obs !== callback);
            };
        },
        
        notificar(datos) {
            observadores.forEach(callback => callback(datos));
        }
    };
}

const evento = crearObservable();

const desuscribir1 = evento.suscribir(datos => console.log("Observer 1:", datos));
const desuscribir2 = evento.suscribir(datos => console.log("Observer 2:", datos));

evento.notificar("¡Hola mundo!"); // Ambos observadores reciben el mensaje

desuscribir1(); // Desuscribe el primer observador
evento.notificar("Solo el segundo observador verá esto");
```

---

## 🛑 Buenas prácticas avanzadas

1. **Prefiere funciones puras** cuando sea posible
2. **Usa closures para encapsular estado privado**
3. **Aprovecha las funciones de orden superior** para código más expresivo
4. **Evita la recursión profunda** sin optimización
5. **Usa memoización** para optimizar funciones costosas
6. **Compón funciones pequeñas** en lugar de crear funciones grandes
7. **Documenta el comportamiento de closures** y contexto
8. **Considera el rendimiento** al usar métodos de array encadenados

!!! warning "Cuidado con la recursión"
    JavaScript no optimiza la recursión de cola, por lo que recursiones muy profundas pueden causar stack overflow. Considera usar iteración o trampolining para casos extremos.

---

## 📚 Ejercicios avanzados

### **Ejercicio 1: Sistema de cache con closures**

```javascript
// Implementa una función que cree un sistema de cache
function crearCache(tiempoExpiracion = 60000) {
    // Tu código aquí
    // Debe retornar un objeto con métodos get, set, clear
}
```

### **Ejercicio 2: Función de debounce**

```javascript
// Implementa una función debounce que retrase la ejecución
function debounce(func, delay) {
    // Tu código aquí
}
```

### **Ejercicio 3: Pipeline de transformaciones**

```javascript
// Crea una función que permita encadenar transformaciones
function pipeline(...funciones) {
    // Tu código aquí
}

// Uso esperado:
// const transformar = pipeline(duplicar, sumarUno, elevarAlCuadrado);
// console.log(transformar(3)); // 49
```


