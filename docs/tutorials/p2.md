# Uso de `import` y `export` en JavaScript Vanilla

Este tutorial te guiará a través de los fundamentos de los módulos en JavaScript, cómo usar `import` y `export`, y cómo aplicarlos en proyectos prácticos. Está diseñado para principiantes, con ejemplos claros y consejos para evitar errores comunes.

## Fundamentos Teóricos

### ¿Por qué usar módulos?
Los módulos permiten dividir el código en archivos separados, cada uno con una responsabilidad específica. Esto mejora:
- **Organización:** Código más legible y mantenible.
- **Reutilización:** Puedes importar solo lo que necesitas en otros archivos.
- **Encapsulamiento:** Limita el acceso a variables y funciones internas, reduciendo conflictos.

JavaScript utiliza el sistema de módulos **ES Modules (ESM)**, introducido en ES6 (2015), que es el estándar moderno para modularización en JavaScript Vanilla.

### Named Exports vs. Default Exports
- **Named Exports**: Permiten exportar múltiples elementos (variables, funciones, clases) desde un módulo, cada uno con un nombre específico. Se importan usando el mismo nombre.
- **Default Exports**: Permiten exportar un solo elemento por módulo como el "valor predeterminado". Se pueden importar con cualquier nombre.

### Cómo maneja JavaScript los módulos
- Los módulos se ejecutan en **modo estricto** (`"use strict"`) por defecto.
- Cada módulo tiene su propio **ámbito (scope)**, por lo que las variables no son globales.
- Los módulos se cargan **una sola vez** y se comparten entre todas las importaciones.
- Los navegadores requieren el atributo `type="module"` en la etiqueta `<script>` para usar ESM.

## Ejemplos Prácticos

### Estructura de Archivos
Organiza tus archivos JavaScript en una estructura clara, con un archivo por módulo. Ejemplo:

```
proyecto/
├── index.html
├── js/
│   ├── main.js
│   ├── mathUtils.js
│   ├── user.js
```

### Named Exports
En `mathUtils.js`, exportamos varias funciones con nombres específicos:

```javascript
// mathUtils.js
export const suma = (a, b) => a + b;
export const resta = (a, b) => a - b;

export function multiplica(a, b) {
  return a * b;
}
```

Importamos en `main.js`:

```javascript
// main.js
import { suma, resta, multiplica } from './mathUtils.js';

console.log(suma(5, 3)); // 8
console.log(resta(5, 3)); // 2
console.log(multiplica(5, 3)); // 15
```

**Nota:** Usa llaves `{}` para importar named exports y especifica los nombres exactos.

### Default Exports
En `user.js`, exportamos una clase como exportación predeterminada:

```javascript
// user.js
export default class User {
  constructor(nombre) {
    this.nombre = nombre;
  }

  saludar() {
    return `¡Hola, ${this.nombre}!`;
  }
}
```

Importamos en `main.js`:

```javascript
// main.js
import User from './user.js'; // Sin llaves, cualquier nombre es válido

const usuario = new User('Ana');
console.log(usuario.saludar()); // ¡Hola, Ana!
```

### Combinando Named y Default Exports
Puedes combinar ambos tipos en un solo módulo. En `mathUtils.js`:

```javascript
// mathUtils.js
export const suma = (a, b) => a + b;
export const resta = (a, b) => a - b;

export default function divide(a, b) {
  if (b === 0) throw new Error('División por cero');
  return a / b;
}
```

Importamos en `main.js`:

```javascript
// main.js
import divide, { suma, resta } from './mathUtils.js';

console.log(suma(5, 3)); // 8
console.log(resta(5, 3)); // 2
console.log(divide(6, 2)); // 3
```

## Uso en Navegadores

Para usar módulos en navegadores, necesitas:
1. **Atributo `type="module"`**: Indica al navegador que el script usa ESM.
2. **Servidor HTTP**: Los módulos no funcionan con URLs `file://` debido a restricciones de seguridad (CORS).

Ejemplo en `index.html`:

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Módulos en JavaScript</title>
</head>
<body>
  <script type="module" src="js/main.js"></script>
</body>
</html>
```






